bl_info = {
    "name": "AI Image Generation",
    "description": "Renders an image generated by AI using the user's perspective as a reference",
    "author": "Developed by Mason Foutz Austin",
    "version": (0, 0, 4),
    "blender": (2, 80, 0),
    "location": "3D View > Tools",
    "warning": "", # used for warning icon and text in addons panel
    "wiki_url": "",
    "tracker_url": "",
    "category": "Development"
}
from collections import namedtuple

Dependency = namedtuple("Dependency", ["module", "package", "name"])
dependencies = (Dependency(module="boto3", package=None, name=None),Dependency(module="replicate", package=None, name=None))
dependencies_installed = False

import bpy
import time
import subprocess
import string
import sys

from bpy.props import (StringProperty,
                       BoolProperty,
                       IntProperty,
                       FloatProperty,
                       FloatVectorProperty,
                       EnumProperty,
                       PointerProperty,
                       )
from bpy.types import (Panel,
                       Menu,
                       Operator,
                       PropertyGroup,
                       )


# ------------------------------------------------------------------------
#    Scene Properties
# ------------------------------------------------------------------------

class MyProperties(PropertyGroup):
    
    prompt: StringProperty(
        name="Prompt",
        description="Text for the AI to generate with",
        default="",
        maxlen=1024,
        )
        
    prompt_strength: FloatProperty(
        name = "Image Strength",
        description = "How much your blender perspective influences the AI",
        default = 0.8,
        min = 0.0,
        max = 1.0
        )
        
    inference_steps: IntProperty(
        name = "Inference Steps",
        description="Number of denoising steps",
        default = 50,
        min = 1,
        max = 500
        )
        
    guidance_scale: FloatProperty(
        name = "Guidance Scale",
        description = "Scale for classifier-free guidance",
        default = 7.5,
        min = 1.0,
        max = 20.0
        )
        
    seed: StringProperty(
        name="Seed",
        description="Seed is random unless specified",
        default="",
        maxlen=1024
        )
        
    outputs: IntProperty(
        name = "Image Quantity",
        description="Number of images for the AI to generate",
        default = 1,
        min = 1,
        max = 10
        )

    api_key: StringProperty(
        name="API Key",
        description="API key for image generation which can be obtained from replicate.com. \nIMPORTANT: This is required for this addon to work!",
        default="",
        maxlen=1024
        )
        
    openbrowser: BoolProperty(
        name="Use browser?",
        description="Will open the results in your browser if true",
        default=True
        )
        
    openfile: BoolProperty(
        name="Open File Location?",
        description="Will open the file location containing the results if true",
        default=True
        )
        
    timer: IntProperty(
        name = "Timer (seconds)",
        description="If this is set, every X seconds images will be generated",
        default = 60,
        min = 0,
        max = 6000
        )
# ------------------------------------------------------------------------
#    Operators
# ------------------------------------------------------------------------

generating = False

def timer_call_fnc():
    print('generating')
    mytool = bpy.data.scenes['Scene'].my_tool
    # Folder path
    folder = bpy.data.filepath[:len(bpy.data.filepath) - bpy.data.filepath[::-1].find('\\')] + '\\ImageGeneration\\'
    
    # Delete old results
    clearPrevious(folder)
    
    # Save a render
    path = saveRender(folder)
        
    # Upload it to s3
    s3response = uploadRender(path)

    # Create AI image
    if s3response is not None:
        generateImages(path, s3response, folder)
    return mytool.timer # call after X seconds

def clearPrevious(folder):
    import os, shutil
    for filename in os.listdir(folder):
        file_path = os.path.join(folder, filename)
        try:
            if os.path.isfile(file_path) or os.path.islink(file_path):
                os.unlink(file_path)
            elif os.path.isdir(file_path):
                shutil.rmtree(file_path)
        except Exception as e:
            print('Failed to delete %s. Reason: %s' % (file_path, e))
            
def saveRender(folder):
    # Save a render
    scene = bpy.data.scenes['Scene']
    render = scene.render
    origx = render.resolution_x
    origy = render.resolution_y
    border_res_x = render.resolution_x * 0.3
    border_res_y = render.resolution_y * 0.3
    render.resolution_x = round(border_res_x) 
    render.resolution_y = round(border_res_y)
    path = folder + 'referenceImage.jpeg'
    bpy.context.scene.render.image_settings.file_format='JPEG'
    bpy.context.scene.render.filepath = path
    bpy.ops.render.render(use_viewport = True, write_still=True)
        
    # Restore old render settings
    render.resolution_x = origx
    render.resolution_y = origy
        
    # Return the path of the saved render
    return path

def uploadRender(path):
    import boto3
    import uuid
    from botocore.exceptions import ClientError
        
    # client for s3 bucket
    alphabets = (string.ascii_lowercase, string.ascii_uppercase, string.digits)
    s3_client = boto3.client('s3', 
                      aws_access_key_id='AKIAQC45DLWIRZZW73MN', 
                      aws_secret_access_key=caesar('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', step=-4, alphabets=alphabets),
                      region_name='us-east-2'
                      )
    key = uuid.uuid4().hex
    bucket = 'raccoonplugin'
        
    # Try to upload
    try:
        response = s3_client.upload_file(path, bucket, key)
    except ClientError as e:
        self.report({"WARNING"}, "S3 Client failed to upload render")
        return None

        
    # Get presigned URL
    try:
        response = s3_client.generate_presigned_url('get_object',
                                                    Params={'Bucket': bucket,
                                                            'Key': key},
                                                    ExpiresIn=120)
    except ClientError as e:
        self.report({"WARNING"}, "S3 Client failed to upload render")
        return None
        
    # Indicate success
    return response

def generateImages(path, response, folder):
    import replicate
    import os
    mytool = bpy.data.scenes['Scene'].my_tool
    os.environ["REPLICATE_API_TOKEN"] = mytool.api_key
    model = replicate.models.get("stability-ai/stable-diffusion")
    version = model.versions.get("8abccf52e7cba9f6e82317253f4a3549082e966db5584e92c808ece132037776")
    if mytool.seed == "":
        output = version.predict(prompt=mytool.prompt, init_image=response, height=512, width=512,
        prompt_strength=mytool.prompt_strength,num_outputs = mytool.outputs, num_inference_steps = mytool.inference_steps, guidance_scale = mytool.guidance_scale)
    else:
        output = version.predict(prompt=mytool.prompt, init_image=response, height=512, width=512,
        prompt_strength=mytool.prompt_strength,num_outputs = mytool.outputs, num_inference_steps = mytool.inference_steps, guidance_scale = mytool.guidance_scale, seed=int(mytool.seed))
        
    if mytool.openbrowser:
        openTabs(output)
    
    downloadImages(output, folder)
    if mytool.openfile:
        subprocess.Popen(r'explorer /select,"C:' + folder + 'referenceImage.jpeg' + r'"')
        
            
def downloadImages(urls, folder):
    import requests

    folder = bpy.data.filepath[:len(bpy.data.filepath) - bpy.data.filepath[::-1].find('\\')] + '\\ImageGeneration\\'
    files = []
    for url in urls:
        filename = folder + url.split('/')[-1]
        files.append(filename)
        r = requests.get(url, allow_redirects=True)
        open(filename, 'wb').write(r.content)

            
def openTabs(urls):
    import webbrowser
    for url in urls:
        webbrowser.open(url, new=2)

class WM_OT_GenerateImage(Operator):
    bl_label = "Start/Stop Image Generation"
    bl_idname = "wm.generate_image"
    bl_description = "Generates images using the selected settings every 60 seconds. Click this button again to stop this behavior."

    def execute(self, context):
        global generating
        mytool = bpy.data.scenes['Scene'].my_tool
        
        if mytool.timer == 0:
            timer_call_fnc()
            return {'FINISHED'}
        
        if not generating:
            bpy.app.timers.register(timer_call_fnc)
            generating = True
            print('Timer started')
        else:
            try:
                bpy.app.timers.unregister(timer_call_fnc)
            except ValueError:
                print("Timer is already unregistered")
            generating = False
            print('Timer stopped')
           
        return {'FINISHED'}
    
def caesar(text, step, alphabets):

    def shift(alphabet):
        return alphabet[step:] + alphabet[:step]

    shifted_alphabets = tuple(map(shift, alphabets))
    joined_aphabets = ''.join(alphabets)
    joined_shifted_alphabets = ''.join(shifted_alphabets)
    table = str.maketrans(joined_aphabets, joined_shifted_alphabets)
    return text.translate(table)

# ------------------------------------------------------------------------
#    Menus
# ------------------------------------------------------------------------

class OBJECT_MT_CustomMenu(bpy.types.Menu):
    bl_label = "Select"
    bl_idname = "OBJECT_MT_custom_menu"

    def draw(self, context):
        layout = self.layout

        # Built-in operators
        layout.operator("object.select_all", text="Select/Deselect All").action = 'TOGGLE'
        layout.operator("object.select_all", text="Inverse").action = 'INVERT'
        layout.operator("object.select_random", text="Random")

# ------------------------------------------------------------------------
#    Panel in Object Mode
# ------------------------------------------------------------------------

class OBJECT_PT_CustomPanel(Panel):
    bl_label = "AI Image Generation"
    bl_idname = "OBJECT_PT_custom_panel"
    bl_space_type = "VIEW_3D"   
    bl_region_type = "UI"
    bl_category = "Tools"
    bl_context = "objectmode"   


    @classmethod
    def poll(self,context):
        return context.object is not None

    def draw(self, context):
        layout = self.layout
        scene = context.scene
        mytool = scene.my_tool

        layout.prop(mytool, "prompt")
        layout.prop(mytool, "prompt_strength")
        layout.prop(mytool, "inference_steps")
        layout.prop(mytool, "guidance_scale")
        layout.prop(mytool, "outputs")
        layout.prop(mytool, "seed")
        layout.prop(mytool, "api_key")
        layout.prop(mytool, "openbrowser")
        layout.prop(mytool, "openfile")
        layout.prop(mytool, "timer")
        layout.operator("wm.generate_image")
        layout.separator()

# ------------------------------------------------------------------------
#    Registration
# ------------------------------------------------------------------------

def import_module(module_name, global_name=None):
    """
    Import a module.
    :param module_name: Module to import.
    :param global_name: (Optional) Name under which the module is imported. If None the module_name will be used.
       This allows to import under a different name with the same effect as e.g. "import numpy as np" where "np" is
       the global_name under which the module can be accessed.
    :raises: ImportError and ModuleNotFoundError
    """
    import importlib

    if global_name is None:
        global_name = module_name

    # Attempt to import the module and assign it to globals dictionary. This allow to access the module under
    # the given name, just like the regular import would.
    globals()[global_name] = importlib.import_module(module_name)


def install_pip():
    """
    Installs pip if not already present. Please note that ensurepip.bootstrap() also calls pip, which adds the
    environment variable PIP_REQ_TRACKER. After ensurepip.bootstrap() finishes execution, the directory doesn't exist
    anymore. However, when subprocess is used to call pip, in order to install a package, the environment variables
    still contain PIP_REQ_TRACKER with the now nonexistent path. This is a problem since pip checks if PIP_REQ_TRACKER
    is set and if it is, attempts to use it as temp directory. This would result in an error because the
    directory can't be found. Therefore, PIP_REQ_TRACKER needs to be removed from environment variables.
    :return:
    """

    try:
        # Check if pip is already installed
        subprocess.run([sys.executable, "-m", "pip", "--version"], check=True)
	subprocess.run([sys.executable, "-m", "pip", "--upgrade", "pip"], check=True)
    except subprocess.CalledProcessError:
        import os
        import ensurepip

        ensurepip.bootstrap()
        os.environ.pop("PIP_REQ_TRACKER", None)


def install_and_import_module(module_name, package_name=None, global_name=None):
    """
    Installs the package through pip and attempts to import the installed module.
    :param module_name: Module to import.
    :param package_name: (Optional) Name of the package that needs to be installed. If None it is assumed to be equal
       to the module_name.
    :param global_name: (Optional) Name under which the module is imported. If None the module_name will be used.
       This allows to import under a different name with the same effect as e.g. "import numpy as np" where "np" is
       the global_name under which the module can be accessed.
    :raises: subprocess.CalledProcessError and ImportError
    """
    import importlib

    if package_name is None:
        package_name = module_name

    if global_name is None:
        global_name = module_name

    # Try to install the package. This may fail with subprocess.CalledProcessError
    subprocess.run([sys.executable, "-m", "pip", "install", package_name], check=True)

    # The installation succeeded, attempt to import the module again
    import_module(module_name, global_name)

class EXAMPLE_PT_warning_panel(bpy.types.Panel):
    bl_label = "Example Warning"
    bl_category = "Example Tab"
    bl_space_type = "VIEW_3D"
    bl_region_type = "UI"

    @classmethod
    def poll(self, context):
        return not dependencies_installed

    def draw(self, context):
        layout = self.layout

        lines = [f"Please install the missing dependencies for the \"{bl_info.get('name')}\" add-on.",
                 f"1. Open the preferences (Edit > Preferences > Add-ons).",
                 f"2. Search for the \"{bl_info.get('name')}\" add-on.",
                 f"3. Open the details section of the add-on.",
                 f"4. Click on the \"{EXAMPLE_OT_install_dependencies.bl_label}\" button.",
                 f"   This will download and install the missing Python packages, if Blender has the required",
                 f"   permissions.",
                 f"If you're attempting to run the add-on from the text editor, you won't see the options described",
                 f"above. Please install the add-on properly through the preferences.",
                 f"1. Open the add-on preferences (Edit > Preferences > Add-ons).",
                 f"2. Press the \"Install\" button.",
                 f"3. Search for the add-on file.",
                 f"4. Confirm the selection by pressing the \"Install Add-on\" button in the file browser."]

        for line in lines:
            layout.label(text=line)


class EXAMPLE_OT_install_dependencies(bpy.types.Operator):
    bl_idname = "example.install_dependencies"
    bl_label = "Install dependencies"
    bl_description = ("Downloads and installs the required python packages for this add-on. "
                      "Internet connection is required. Blender may have to be started with "
                      "elevated permissions in order to install the package")
    bl_options = {"REGISTER", "INTERNAL"}

    @classmethod
    def poll(self, context):
        # Deactivate when dependencies have been installed
        return not dependencies_installed

    def execute(self, context):
        try:
            install_pip()
            for dependency in dependencies:
                install_and_import_module(module_name=dependency.module,
                                          package_name=dependency.package,
                                          global_name=dependency.name)
        except (subprocess.CalledProcessError, ImportError) as err:
            self.report({"ERROR"}, str(err))
            return {"CANCELLED"}

        global dependencies_installed
        dependencies_installed = True

        # Register the panels, operators, etc. since dependencies are installed
        for cls in classes:
            bpy.utils.register_class(cls)

        return {"FINISHED"}


class EXAMPLE_preferences(bpy.types.AddonPreferences):
    bl_idname = __name__

    def draw(self, context):
        layout = self.layout
        layout.operator(EXAMPLE_OT_install_dependencies.bl_idname, icon="CONSOLE")


preference_classes = (EXAMPLE_PT_warning_panel,
                      EXAMPLE_OT_install_dependencies,
                      EXAMPLE_preferences)

classes = (
    MyProperties,
    WM_OT_GenerateImage,
    OBJECT_MT_CustomMenu,
    OBJECT_PT_CustomPanel
)

preference_classes = (EXAMPLE_PT_warning_panel,
                      EXAMPLE_OT_install_dependencies,
                      EXAMPLE_preferences)

def register():
    import sys
    import os
    from bpy.utils import register_class

    #make folder
    newpath = r'C:\\ImageGeneration' 
    if not os.path.exists(newpath):
        os.makedirs(newpath)
    
    #install packages
    global dependencies_installed
    dependencies_installed = False

    for cls in preference_classes:
        bpy.utils.register_class(cls)

    try:
        for dependency in dependencies:
            import_module(module_name=dependency.module, global_name=dependency.name)
        dependencies_installed = True
    except ModuleNotFoundError:
        # Don't register other panels, operators etc.
        return

    for cls in classes:
        register_class(cls)
    bpy.types.Scene.my_tool = PointerProperty(type=MyProperties)

def unregister():
    from bpy.utils import unregister_class
    for cls in reversed(classes):
        unregister_class(cls)
    del bpy.types.Scene.my_tool
    try:
        bpy.app.timers.unregister(timer_call_fnc)
    except ValueError:
        print("Timer is already unregistered")
    
    for cls in preference_classes:
        bpy.utils.unregister_class(cls)

    if dependencies_installed:
        for cls in classes:
            bpy.utils.unregister_class(cls)


if __name__ == "__main__":
    register()
